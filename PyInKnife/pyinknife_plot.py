#!/usr/bin/env python
# -*- Mode: python; tab-width: 4; indent-tabs-mode:nil; coding:utf-8 -*-

#    pyinknife-plot.py
#
#    Plot aggregated data generated by pyinknife-aggregate.
#
#    Copyright (C) 2020 Valentina Sora 
#                       <sora.valentina1@gmail.com>
#                       Juan Salamanca Viloria 
#                       <juan.salamanca.viloria@gmail.com> 
#                       Elena Papaleo
#                       <elenap@cancer.dk>
#
#    This program is free software: you can redistribute it and/or
#    modify it under the terms of the GNU General Public License as
#    published by the Free Software Foundation, either version 3 of
#    the License, or (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public
#    License along with this program. 
#    If not, see <http://www.gnu.org/licenses/>.

import argparse
import logging
import os
import os.path

import matplotlib.pyplot as plt
import pandas as pd
import yaml

from . import util


def main():


    ######################### ARGUMENT PARSER #########################


    # description of the script
    description = "\nPlot aggregated data generated by the " \
                  "PyinKnife pipeline.\n"
    
    # create the argument parser
    parser = argparse.ArgumentParser(description = description)
    
    # add arguments
    c_help = f"Configuration file used to run the pipeline. " \
             f"Default is {util.DEFCONFIG}."
    parser.add_argument("-c", "--configfile", \
                        type = str, \
                        default = util.DEFCONFIG, \
                        help = c_help)

    ca_help = f"Configuration file used for the data aggregation. " \
              f"Default is {util.DEFCONFIGAGGR}."
    parser.add_argument("-ca", "--configfile-aggregate", \
                        type = str, \
                        default = util.DEFCONFIGAGGR, \
                        help = ca_help)

    cp_help = "Configuration file for plotting. " \
              "Default depends on what you want to plot."
    parser.add_argument("-cp", "--configfile-plot", \
                        type = str, \
                        default = None,
                        help = cp_help)

    p_default = "hubs"
    p_help = f"What to plot. Default is {p_default}."
    parser.add_argument("-p", "--plot", \
                        type = str, \
                        default = p_default, \
                        help = p_help)

    d_help = "Directory where the aggregate outputs are saved."
    parser.add_argument("-d", "--rundir", \
                        type = str, \
                        required = True, \
                        help = d_help)

    od_help = "Directory where to save the output plots. " \
              "Default is the current working directory."
    parser.add_argument("-od", "--outdir", \
                        type = str, \
                        required = True, \
                        help = od_help)


    # parse the arguments
    args = parser.parse_args()
    # get single arguments
    configfile = util.get_abspath(args.configfile)
    configfile_aggregate = util.get_abspath(args.configfile_aggregate)
    configfile_plot = util.get_abspath(args.configfile_plot)
    plot = args.plot
    rundir = util.get_abspath(args.rundir)
    outdir = util.get_abspath(args.outdir)


    ########################## CONFIGURATION ##########################

    # if the user did not provide a custom configuration file
    # for plotting
    if not configfile_plot:
        # if plotting hubs
        if plot == "hubs":
            # get the default configuration file for hubs
            configfile_plot = util.DEFCONFIGHUBS
        # if plotting connected components
        elif plot == "ccs":
            # get the default configuration file for connected
            # components
            configfile_plot = util.DEFCONFIGCCS
        # get the absolute path to the configuration file
        configfile_plot = util.get_abspath(configfile_plot) 

    # load the pipeline configuration
    config = yaml.safe_load(open(configfile, "r"))
    # load the data aggregation configuration
    aggrconfig = yaml.safe_load(open(configfile_aggregate, "r"))
    # load the plot configuration
    fullplotconfig = yaml.safe_load(open(configfile_plot, "r"))
    
    # configuration of the resamplings
    resconfig = config["resampling"]
    # numer of resamplings
    nsamplings = resconfig["nsamplings"]
    # trajectory names
    trjnames = resconfig["dirnames"]
    # name of the full trajectory
    trjname = trjnames["trj"]
    # names of the resampled trajectories
    subtrjnames = \
        [trjnames["subtrj"].replace(r"{nsampling}", str(i)) \
         for i in range(nsamplings)]

    # extension of the aggregate file
    extension = aggrconfig["output"]["extension"].lstrip(".")
    # field separator in the aggregate file
    sep = aggrconfig["output"]["sep"]
    # column used as index in the aggregate file
    indexcol = aggrconfig["output"]["indexcol"]

    # column names for statistics in the aggregate file
    meancol = aggrconfig["columns"]["mean"]
    maxcol = aggrconfig["columns"]["max"]
    semcol = aggrconfig["columns"]["sem"]

    # name of the plot to be generated (taken from the name of
    # the plot configuration file)
    plotname = os.path.basename(configfile_plot).rstrip(".yaml")

    # get the main logger
    logger = logging.getLogger(__name__)


    ######################### PLOT GENERATION #########################


    # if the output directory does not exist, create it
    os.makedirs(outdir, exist_ok = True)

    # for each item in the aggregated output directory
    for infilename in os.listdir(rundir):

        ishubs = infilename.rstrip(extension).endswith("hubs.")
        isccs = infilename.rstrip(extension).endswith("ccs.")
        
        if not ((plot == "hubs" and ishubs) \
        or (plot == "ccs" and isccs)):
            continue
        
        # get the full path to the item
        infile = os.path.join(rundir, infilename)
        
        # if the item is a directory
        if os.path.isdir(infile):
            # ignore it
            continue
        
        # read the dataframe
        df = pd.read_csv(infile, \
                         sep = sep, \
                         index_col = indexcol)

        # get the plot and output configuration
        plotconfig = fullplotconfig["plot"]
        outconfig = fullplotconfig["output"]
        
        # if the plot requested for the connected components
        # is a bar plot
        if plotname in ("plot_ccs_barplot", "plot_hubs_barplot"):

            # values to be used to set the x-axis interval
            xvalues = range(len(df))

            # values to be used to set the y-axis interval
            yvalues = df[maxcol]
            
            # create the figure and axes
            fig, ax = plt.subplots()
            
            # generate the bar plot
            ax = util.set_barplot(ax = ax, \
                                  df = df, \
                                  y = meancol, \
                                  yerr = semcol, \
                                  config = plotconfig["bar"])
        
        else:
            # inform the user of the error
            errstr = f"{plotname} is not a valid name for a plot " \
                     f"configuration file."
            logger.error(errstr)
            # exit with code 1
            exit(1)

        # get the x-axis configuration
        xaxisconfig = plotconfig["xaxis"]
        # get the x-axis interval
        xinterval = util.get_interval(values = xvalues, \
                                      config = xaxisconfig)
        # set the x-axis
        ax = util.set_axis(ax = ax, \
                           axis = "x", \
                           config = xaxisconfig, \
                           ticks = xinterval, \
                           ticklabels = df.index)

        # get the y-axis configuration
        yaxisconfig = plotconfig["yaxis"]
        # get the y-axis interval
        yinterval = util.get_interval(values = yvalues, \
                                      config = yaxisconfig)

        # set the y-axis
        ax = util.set_axis(ax = ax, \
                           axis = "y", \
                           config = yaxisconfig, \
                           ticks = yinterval)

        # remove top and right spines
        for spine in ["top", "right"]:
            ax.spines[spine].set_visible(False)

        # push the remaining spines a bit outward
        for spine in ["bottom", "left"]:
            ax.spines[spine].set_position(("outward", 5))

        # get the output file name by replacing the extension
        # of the aggregate file name
        outfile = os.path.join(outdir, \
                               infilename.replace(extension, \
                                                  outconfig["format"]))
        # save the plot to the output file
        plt.savefig(outfile, **outconfig)



if __name__ == "__main__":
    main()