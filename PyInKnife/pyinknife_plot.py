#!/usr/bin/env python
# -*- Mode: python; tab-width: 4; indent-tabs-mode:nil; coding:utf-8 -*-

#    pyinknife_plot.py
#
#    Plot aggregated data generated by ``pyinknife_aggregate``.
#
#    Copyright (C) 2023 Valentina Sora 
#                       <sora.valentina1@gmail.com>
#                       Juan Salamanca Viloria 
#                       <juan.salamanca.viloria@gmail.com>
#                       Matteo Tiberti 
#                       <matteo.tiberti@gmail.com>
#                       Elena Papaleo
#                       <elenap@cancer.dk>
#
#    This program is free software: you can redistribute it and/or
#    modify it under the terms of the GNU General Public License as
#    published by the Free Software Foundation, either version 3 of
#    the License, or (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public
#    License along with this program. 
#    If not, see <http://www.gnu.org/licenses/>.


# Standard library
import argparse
import logging as log
import os
import os.path
import sys
# Third-party packages
import matplotlib.pyplot as plt
import pandas as pd
import yaml
# PyInKnife2
from . import util


def main():


    #------------------------ Argument parser ------------------------#


    # description of the script
    description = \
        "\nPlot aggregated data generated by the PyinKnife pipeline.\n"
    
    # Create the argument parser
    parser = argparse.ArgumentParser(description = description)
    
    # Add arguments
    c_help = \
        f"The configuration file that was used to run the " \
        f"pipeline. The default is '{util.DEF_CONFIG}'."
    parser.add_argument("-c", "--configfile",
                        type = str,
                        default = util.DEF_CONFIG,
                        help = c_help)

    ca_help = \
        f"The configuration file that was used for data " \
        f"aggregation. The default is '{util.DEF_CONFIG_AGGR}'."
    parser.add_argument("-ca", "--configfile-aggregate",
                        type = str,
                        default = util.DEF_CONFIG_AGGR,
                        help = ca_help)

    cp_help = \
        f"The configuration file that will be used for plotting. " \
        f"The default depends on what is defined by the " \
        f"'p', '--plot' option. All default files for plotting " \
        f"can be found in '{util.CONFIG_DIR}'."
    parser.add_argument("-cp", "--configfile-plot",
                        type = str,
                        default = None,
                        help = cp_help)

    p_choices = ["hubs", "ccs"]
    p_choices_str = ", ".join(f"'{c}'" for c in p_choices)
    p_default = "hubs"
    p_help = \
        f"What to plot. The available choices are {p_choices_str}. " \
        f"The default is '{p_default}'."
    parser.add_argument("-p", "--plot",
                        type = str,
                        choices = p_choices,
                        default = p_default,
                        help = p_help)

    d_help = \
        "The directory where the aggregate files are. Use '.' " \
        "to indicate that the aggregate files are in the " \
        "current working directory."
    parser.add_argument("-d", "--rundir",
                        type = str,
                        required = True,
                        help = d_help)

    od_help = \
        "The directory where the output plots will be saved."
    parser.add_argument("-od", "--outdir",
                        type = str,
                        required = True,
                        help = od_help)


    # Parse the arguments
    args = parser.parse_args()
    
    # Get the arguments
    config_file = util.get_abspath(args.configfile)
    config_file_aggregate = util.get_abspath(args.configfile_aggregate)
    config_file_plot = util.get_abspath(args.configfile_plot)
    plot = args.plot
    run_dir = util.get_abspath(args.rundir)
    out_dir = util.get_abspath(args.outdir)


    #---------------------------- Logging ----------------------------#


    # Get the module logger
    logger = log.getLogger(__name__)

    # Configure the logger
    log.basicConfig(level = log.INFO)


    #------------------------- Configuration -------------------------#


    # If the user did not provide a custom configuration file
    # for plotting
    if config_file_plot is None:
        
        # If we are plotting hubs
        if plot == "hubs":
            
            # Get the default configuration file for hubs
            config_file_plot = util.DEF_CONFIG_HUBS
        
        # If we are plotting connected components
        elif plot == "ccs":
            
            # Get the default configuration file for connected
            # components
            config_file_plot = util.DEF_CONFIG_CCS
        
        # Get the absolute path to the configuration file
        config_file_plot = util.get_abspath(config_file_plot)

        # Inform the user that we are using the default configuration
        # file
        infostr = \
            f"Using the default configuration file to plot " \
            f"'{plot}': '{config_file_plot}'."
        logger.info(infostr)

    # Try to load the configuration used for the run
    try:

        config = \
            util.get_pyinknife_configuration(\
                config_file = config_file)

    # If something went wrong
    except Exception as e:

        # Log an error and exit
        errstr = \
            f"It was not possible to load the configuration used " \
            f"for the run from '{config_file}'. Error: {e}"
        logger.exception(errstr)
        sys.exit(errstr)
    
    # Try to load the configuration for data aggregation
    try:

        aggr_config = \
            yaml.safe_load(open(config_file_aggregate, "r"))

    # If something went wrong
    except Exception as e:

        # Log an error and exit
        errstr = \
            f"It was not possible to load the configuration for " \
            f"data aggregation from '{config_file_aggregate}'. " \
            f"Error: {e}"
        logger.exception(errstr)
        sys.exit(errstr)

    # Try to load the configuration for plotting
    try:

        full_plot_config = \
            yaml.safe_load(open(config_file_plot, "r"))

    # If something went wrong
    except Exception as e:

        # Log an error and exit
        errstr = \
            f"It was not possible to load the configuration for " \
            f"plotting from '{config_file_plot}'. " \
            f"Error: {e}"
        logger.exception(errstr)
        sys.exit(errstr)
    
    
    # Configuration of the resamplings
    res_config = config["resampling"]

    # Numer of resamplings performed
    n_samplings = res_config["nsamplings"]
    
    # Trajectory names
    trj_names = res_config["dirnames"]
    
    # Name of the full trajectory
    trj_name = trj_names["trj"]

    # Names of the resampled trajectories
    sub_trj_names = \
        [trj_names["subtrj"].replace(r"{nsampling}", str(i)) \
         for i in range(n_samplings)]

    # Extension of the aggregate file
    extension = aggr_config["output"]["extension"].lstrip(".")
    
    # Field separator in the aggregate file
    sep = aggr_config["output"]["sep"]
    
    # Column used as index in the aggregate file
    index_col = aggr_config["output"]["indexcol"]

    # Column names for statistics in the aggregate file
    mean_col = aggr_config["columns"]["mean"]
    max_col = aggr_config["columns"]["max"]
    sem_col = aggr_config["columns"]["sem"]


    #----------------------- Output directory ------------------------#


    # If the output directory does not exist yet
    if not os.path.exists(out_dir):

        # Create it
        os.makedirs(out_dir, exist_ok = True)

        # Inform the user that the directory was created
        infostr = \
            f"The directory '{out_dir}' was created."
        logger.info(infostr)
    
    # Otherwise
    else:

        # Inform the user that the directory was found
        infostr = \
            f"The directory '{out_dir}' was found."
        logger.info(infostr)


    #----------------------------- Plot ------------------------------#


    # For each item in the aggregated output directory
    for in_filename in os.listdir(run_dir):

        # Get whether the file contains results for hubs or
        # connected components
        is_hubs = in_filename.rstrip(extension).endswith("hubs.")
        is_ccs = in_filename.rstrip(extension).endswith("ccs.")
        
        # If the file contains neither results for the hubs nor
        # results for the connected components
        if not ((plot == "hubs" and is_hubs) \
                or (plot == "ccs" and is_ccs)):

            # Skip it
            continue
        
        # Get the full path to the item
        in_file = os.path.join(run_dir, in_filename)
        
        # If the item is a directory
        if os.path.isdir(in_file):
            
            # Ignore it
            continue
        
        # Read in the aggregated results as a data frame
        df = pd.read_csv(in_file,
                         sep = sep,
                         index_col = index_col)

        # If the data frame is empty
        if df.empty:

            # Inform the user about it
            infostr = f"The data frame found in '{in_file}' is empty."
            logger.info(infostr)
            
            # Go on to the next data frame
            continue

        # Get the plot and output configuration
        plot_config = full_plot_config["plot"]
        out_config = full_plot_config["output"]

        # Values to be used to set the x-axis interval
        x_values = range(len(df))

        # Values to be used to set the y-axis interval
        y_values = df[max_col]
            
        # Create the figure and axes
        fig, ax = plt.subplots()
            
        # Generate the bar plot
        ax = util.set_barplot(ax = ax,
                              df = df,
                              y = mean_col,
                              yerr = sem_col,
                              config = plot_config["bar"])

        # Get the x-axis configuration
        x_axis_config = plot_config["xaxis"]
        
        # Get the x-axis interval
        x_interval = util.get_axis_interval(values = x_values, 
                                            config = x_axis_config)

        # Set the x-axis
        ax = util.set_axis(ax = ax,
                           axis = "x",
                           config = x_axis_config,
                           ticks = x_interval,
                           ticklabels = df.index)

        # Get the y-axis configuration
        y_axis_config = plot_config["yaxis"]
        
        # Get the y-axis interval
        y_interval = util.get_axis_interval(values = y_values,
                                            config = y_axis_config)

        # Set the y-axis
        ax = util.set_axis(ax = ax,
                           axis = "y",
                           config = y_axis_config,
                           ticks = y_interval)

        # Remove top and right spines
        for spine in ["top", "right"]:
            ax.spines[spine].set_visible(False)

        # Push the remaining spines a bit outward
        for spine in ["bottom", "left"]:
            ax.spines[spine].set_position(("outward", 5))

        # Get the output file name by replacing the extension
        # of the aggregate file name
        out_file = \
            os.path.join(out_dir,
                         in_filename.replace(extension,
                                             out_config["format"]))
        
        # Save the plot to the output file
        plt.savefig(out_file, **out_config)



if __name__ == "__main__":
    main()